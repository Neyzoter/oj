# 两数相加问题（AddTwoNumbers）
## 1.问题
给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。

你可以假设除了数字 0 之外，这两个数字都不会以零开头。

示例：

输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)

输出：7 -> 0 -> 8

原因：342 + 465 = 807

## 2.思路
1、创建缓存ListNode单链表的temp1,temp2和sum_temp

分别用于指向输入单链表1的某个节点，输入单链表2的某个节点，相加的结果的单链表的某个节点

2、一次从单链表的第一个开始遍历（第一个节点即个位，第二个节点即十位...）

两个单链表的数值和进c位相加后%10提取保留的数，/10提取进位c。

注意：在遍历到都是null时，进位有可能还有数值，需要另外判断。

## 3.感悟

进位问题：需要考虑没有相加的数，但是还是有进位的情况。

# 盛最多水的容器问题（ContainerWithMostWater）
(下标1-下标2)*(高度)
## 1.思路
### 1.1 暴力法
1、两个for循环

获取最大的面积

*时间复杂度*:O(n^2)

*空间复杂度*:O(1)

### 1.2 指针法
由于限制面积的总是高度低的，所以需要将高度低的指针向内侧移动。

为了使面积最大化，我们需要考虑更长的两条线段之间的区域。如果我们试图将指向较长线段的指针向内侧移动，矩形区域的面积将受限于较短的线段而不会获得任何增加。

另外的理解：移动高度高的，没有必要了。不过就算没有遍历，也不会有遗漏的地方。

# 无重复字符的最长子串问题（LongestSubstringWithoutRepeatingCharacters）
## 1.问题
给定一个字符串，找出不含有重复字符的最长子串的长度。

示例 1:

```
输入: "abcabcbb"
输出: 3 
解释: 无重复字符的最长子串是 "abc"，其长度为 3。
```

示例 2:

```
输入: "bbbbb"
输出: 1
解释: 无重复字符的最长子串是 "b"，其长度为 1。
```

示例 3:

```
输入: "pwwkew"
输出: 3
解释: 无重复字符的最长子串是 "wke"，其长度为 3。
     请注意，答案必须是一个子串，"pwke" 是一个子序列 而不是子串。
```

## 2.思路
### 2.1 哈希表法
1、从start=0,end=0开始遍历

2、在哈希表中查看是否有end下标对因的数值，如果有那么就更新start

start是end下标对因数值在哈希表中的下标和本次start的值中大的。

为什么要这么做呢？

如"abccb"。遍历到最后一个b时，可以查到哈希表中有b（第一个b），但是此时start时第二个c下标。所以可见不能小于start当前的下标，会造成来两个b中间有c重复。

3、将本次end对因的数值和下标+1put到哈希表中（会覆盖原来的<数值,下标+1>）

4、更新长度

*时间复杂度*:O(n)

*空间复杂度*:O(n)

### 2.2 暴力法
1、start=0,end=0开始遍历

2、每次end增加1次，就用一个idx_find下标来遍历从下标start到end前一个，是否有和end下标所在的数值相等的

如果相等就移动start到idx_find

3、如果最大长度end-start+1变大了，就更新长度

*时间复杂度*:O(n^2)

*空间复杂度*:O(1)

## 3.感悟
* 子序列和子串
    
    子序列：子序列中的字符串不一定在原字符串中连在一起，而且是按照ASCII码顺序排序。
    
    子串：子串中的字符串在原字符串中连在一起。
    
    
# 两个排序数组的中位数（MiddleOfTwoSortedArrays）

## 1.问题
给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。

请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。

示例 1:

nums1 = [1, 3]
nums2 = [2]

中位数是 2.0

示例 2:

nums1 = [1, 2]
nums2 = [3, 4]

中位数是 (2 + 3)/2 = 2.5

## 2.思路
1.判断数组降序还是升序，并设定从小的开始取数

2.判断两个数组中小的，取出

3.直到取到中位数

3.1 中位数通过`(m+n+1)%2`来判断是（等于1）否（等于0）需要平均

# 14 最长公共前缀
## 1.问题
编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 ""。

示例 1:

```
输入: ["flower","flow","flight"]
输出: "fl"
```

示例 2:

```
输入: ["dog","racecar","car"]
输出: ""
解释: 输入不存在公共前缀。
说明:
所有输入只包含小写字母 a-z 。
```

## 2.思路
### 2.1 暴力搜索
```
minlen = strs[0].len
strnum = strs.len
For str : strs
    If str.len < minlen
        minlen = str.len
    End
End

prefix = ""
For i = 0 : minlen - 1
    ch = strs[0].charAt(i)
    For str : strs
        If str.charAt(i) != ch
            return prefix
    End
    prefix += ch
End
```

# 15 三数之和
中等

## 1.问题

给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。

例如, 给定数组` nums = [-1, 0, 1, 2, -1, -4]`，

满足要求的三元组集合为：

```
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```


## 2.思路
### 2.1 最终思路

1、nums排序

2、首先确定三个数中最小的数，得到其余两个数之和的目标，从左往右遍历

3、再使用双指针法得到中间数、最大数

*遍历过程注意点*

* 越大的数，下标一定比小的数下标大。

* 最小的数遍历到倒数第三个即可。

* 确定最小的数的时候，如果和前面一个的相同，可以直接跳过。

因为当前最小数后面遍历的数集合是前一个相同的数后面遍历的数集合的子集。

[-1,-1,-1,0,1,1,2]，可见第一个-1后面的数肯定比第二个-1后面的数多，是子集关系。第二个-1作为最小数所做的遍历结果，一定包含在第一个-1作为最小数所做的遍历结果当中。

*时间复杂度*:O(n^2)

*空间复杂度*:O(1)??

## 2.2 其他思路
### 2.2.1 步骤
1、nums排序

2、先确定三个数（小、中、大排序）的中间那个，得到其余的两个数相加需要多大。

3、开始向左边和右边遍历，寻找最小的值和最大的值。

### 2.2.2 说明

*问题*

需要考虑左边和右边遍历的数是否会影响到最终出来的结果是重复的，较麻烦。

*特点*

减少遍历的时间。

## 3.感悟
* 双指针法

目标：两个数相加和target相等，且找到的数不重复

方法：

1、排序数组

2、一个（min）从最小开始，一个（max）从最大开始。

3、如果相加大于target，则max减小，即max下标减小。

如果相加小于target，则min增大，即max下标增大。

4、如果相加等于target，则保存这组数。

双指针同时向对方靠拢，min下标变大，max下标变小。

同时，**为了防止重复**，如果max和上一个相等，则跳过，到达在下一个。min同理。

```Java
while(idx_mid<idx_max&&nums[idx_mid]==nums[idx_mid-1]) {
						idx_mid++;
					}
```

# 16 最接近的三数之和（ThreeSumClosest）
中等
## 1.问题

给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。

例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.

与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).

## 2.思路
使用三指针，i从头到尾遍历，再通过两个指针（在i右边的最左侧和最右侧开始）left和right，left只能增大（三数和随之增大），right只能减小（三数和随之减小）。和target的对比，通过调节left和right的移动来增大或者减小三数之和，进而找到最接近的数。


# 17 电话号码的字母组合（LetterCombinations）

## 1. 问题
给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

```
2：abc
3：def
4：ghi
5：jki
6：mno
7：pqrs
8：tuv
9：wxyz
```

## 2.思路
1.创建一个字符串数组，保存字母V1；将字符串转化为整数型数组V2；创建要返回的String列表ans
2.For循环中创建数组

```
FOR int i : V2
    int len = ans.len==0?1:ans.len;
    String thisS = V1[i]
    WHILE len--
        String s = ans.remove
        FOR char ch : thisS.toCharArray
              ans.add(s+ch)
        END
    END
END
```

# 31.下一个排列（Next Permutation）
## 1.问题
实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。

```
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
```

## 2.思路

```
nums[N]

For i = N-2 : 0
    tmp = nums[i]
    If nums[i] < nums[N-1]
        For j = i + 1 : N - 1
            If nums[i] < nums[j]  
                nums[i] = nums[j]
                nums[j] = tmp
                return
            End
        End
    Else
        For j = i + 1 : N - 1
            nums[j - 1] = nums[j]
        End
        nums[N-1] = tmp
    End
End
```


# 53. 最大子序和（Max SubArray）
## 1.问题
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

输入: `[-2,1,-3,4,-1,2,1,-5,4]`,

输出: 6

解释: 连续子数组 `[4,-1,2,1]` 的和最大，为 6。

进阶:

如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。

## 2.思路

### 动态规划

遍历，每次找到遍历元素为结尾的最大子序和

### 暴力法

遍历，两个变量，1个保存最大的和，1个记录当前的和。每次发现当前和加上下一个元素比下一个元素小了，说明当前和需要重新计算了。

# 79 单词搜索（WordSearch）
## 1.问题
给定一个二维网格和一个单词，找出该单词是否存在于网格中。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

示例:

```
board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]
```


给定 word = "ABCCED", 返回 true.

给定 word = "SEE", 返回 true.

给定 word = "ABCB", 返回 false.

## 2.思路
使用回溯算法，字母表（已经使用的字母用空格代替）、单词剩下的部分，开始的坐标作为输入，直到单词剩下部分为0.

*注意*：二维数组赋值深拷贝需要通过特定函数实现，如`System.arraycopy`，但是`System.arraycopy`只能对某个对象操作，不能直接操作二维数组，所以需要写一个for。对于某一个类的数组，也需要逐个深拷贝。

```java
char[][] boardNext = new char[board.length][board[0].length];
for (int idx = 0; idx < board.length;idx ++){
    System.arraycopy(board[idx],0,boardNext[idx],0,board[0].length);
}
```

# 283 移动零（MoveZeroes）
数组、双指针

## 1.问题
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

示例:

输入: [0,1,0,3,12]

输出: [1,3,12,0,0]

说明:

必须在原数组上操作，不能拷贝额外的数组。尽量减少操作次数。

## 2.思路
在原数组上遍历，不是零则放到前面。遍历完后，数组后面没有赋值过的就置零。

空间复杂度O(n)

时间复杂度O(1)


