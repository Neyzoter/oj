# 两数之和问题（AddTwoNumbers）
## 1.问题
给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。

你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。

示例:

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9

所以返回 [0, 1]

## 2.思路
### 2.1 暴力法
两个for循环依次遍历，较简单

*时间复杂度*:O(n^2)

*空间复杂度*:O(1)

### 2.2 两次遍历Hash表法
1、将nums数据保存在哈希表中，以<数值，下标>存储，即数值对因键值，下标对因数值。

2、for循环遍历nums（得到nums[i]），并得到对应的另外一个数的数值target-nums[i]。

3、哈希表查找对因的数值，并判断查找到的下标是否和i相同，相同则舍弃（不能重复使用）

说明：哈希表查询可以达到O(1)时间复杂度

*时间复杂度*:O(n)

*空间复杂度*:O(n)

### 2.3 一次遍历hash表法
一边存一边回退查看hash表中是否有对因的值

*时间复杂度*:O(n^2)

*空间复杂度*:O(1)

## 3.感悟
HashMap可以提高遍历的速度，达到O(1)时间复杂度。

用空间换取了时间。

# 删除链表的倒数第N个节点问题（RemoveNthNodeFromEndofList）
## 1.问题
给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。

示例：

```
给定一个链表: 1->2->3->4->5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1->2->3->5.
```

说明：

给定的 n 保证是有效的。

进阶：

你能尝试使用一趟扫描实现吗？

## 2.思路
### 2.1 暴力法
遍历两遍

*时间复杂度*:O(n^2)

*空间复杂度*:O(1)

### 2.2 双指针法
1、尾部指针先指向要删除指针（其实此时指向要删除指针的前一个）的后面第n个

考虑n个节点，删除倒数第n个的特殊情况

2、如果尾部指针后面还有，则尾部指针和要删除指针均往后移动一个

3、尾部指针已经到达了最后一个，要删除的节点的前一个节点指向要删除节点的后一个。

*时间复杂度*:O(n),n个节点

*空间复杂度*:O(1)
