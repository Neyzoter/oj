# 最长回文子串问题（LongestPalindromicSubstring）
## 1.问题
给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。

*回文串*是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。

示例 1：

```
输入: "babad"
输出: "bab"
注意: "aba"也是一个有效答案。
```

示例 2：

```
输入: "cbbd"
输出: "bb"
```

## 2.思路
### 2.1 中心扩散法
分成两种情况，一种是奇数个，一种是偶数个。

*奇数个*

1、确定中间的数

2、向两边遍历

*偶数个*

1、确定中间两个数

2、向两边遍历

*时间复杂度*:O(n^2)

*空间复杂度*:O(1)

### 2.2 动态规划法
1、先找长度1和2的回文子串，并存储在矩阵中

也就是先给(0,0)(1,1)(2,2)...(0,1)(1,2)(2,3)...赋值，false或者true。分别表示字符串下标i到j之间的部分是不是回文子串。

2、遍历长度3的回文子串，长度4的回文子串，以此类推

```
for(长度){
    for(下标遍历){
    	判断[本次下标,本次下标+长度]
    }
}
```

## 3.感悟
### 3.1 最长公共子串
给定两个字符串，求出它们之间最长的相同子字符串的长度。

**解决方法**

* 暴力法

以字符串中的每个字符作为子串的端点，判定以此为开始的子串的相同字符最长能达到的长度。。其实从表层上想，这个算法的复杂度应该只有O(n2)因为该算法把每个字符都成对相互比较一遍，但关键问题在于比较两个字符串的效率并非是O(1)，这也导致了实际的时间复杂度应该是满足Ω(n^2)和O(n^3)。

* 动态规划

在比较以i和j分别为起始点字符串时，有可能会进行i+1和j+1以及i+2和j+2位置的字符的比较；而在比较i+1和j+1分别为起始点字符串时，这些字符又会被比较一次了。也就是说该问题有非常相似的子问题，而子问题之间又有重叠，这就给动态规划法的应该提供了契机。
